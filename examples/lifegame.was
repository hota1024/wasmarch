import std {
  fn newline();
  fn log_i32(i32);
  fn log_i32x3(i32, i32, i32);
  fn random_bool(): i32;
}

export global grid_width = 42;
export global grid_height = 34;
export global grid_pixel_size = 16.0;

global CELL_LIVE = 0x00aaff;
global CELL_DEAD = 0xffffff;

global P_BOARD = 0;
global mut P_NEXT = 0;
global mut frame = 0;

export mem grid_memory(1);

fn point_to_index(p: i32, x: i32, y: i32): *i32 {
  (p + (y * grid_width + x) * 4) as *i32
}

fn get(p: i32, x: i32, y: i32): i32 {
  if x < 0 || x > grid_width - 1 || y < 0 || y > grid_height - 1 {
    return CELL_DEAD;
  };

  *point_to_index(p, x, y)
}

fn set(p: i32, x: i32, y: i32, color: i32) {
  *point_to_index(p, x, y) = color
}

fn count_around(p: i32, x: i32, y: i32, c: i32): i32 {
  let count = 0;

  if get(p, x + 1, y) == c {
    count += 1;
  };

  if get(p, x - 1, y) == c {
    count += 1;
  };

  if get(p, x, y + 1) == c {
    count += 1;
  };

  if get(p, x, y - 1) == c {
    count += 1;
  };

  if get(p, x + 1, y + 1) == c {
    count += 1;
  };

  if get(p, x - 1, y + 1) == c {
    count += 1;
  };

  if get(p, x + 1, y - 1) == c {
    count += 1;
  };

  if get(p, x - 1, y - 1) == c {
    count += 1;
  };

  count
}

fn mem_copy(src: i32, dest: i32) {
  let x = 0;
  let y = 0;
  let c = 0;

  while x < grid_width {
    y = 0;
    while y < grid_height {
      set(dest, x, y, get(src, x, y));

      y += 1;
    };
    x += 1;
  };
}

export fn grid_frame() {
  frame += 1;

  @memory_copy(P_NEXT, P_BOARD, grid_width * grid_height * 4);

  let x = 0;
  let y = 0;
  let cur = 0;
  let count = 0;
  let next_state = 0;

  while x < grid_width {
    y = 0;
    while y < grid_height {
      cur = get(P_BOARD, x, y);
      count = count_around(P_BOARD, x, y, CELL_LIVE);
      next_state = 0-1;

      if cur == CELL_LIVE && count < 2 {
        next_state = CELL_DEAD;
      };

      if next_state == 0-1 && cur == CELL_LIVE && count > 3 {
        next_state = CELL_DEAD;
      };

      if next_state == 0-1 && cur == CELL_DEAD && count == 3 {
        next_state = CELL_LIVE;
      };

      if next_state == 0-1 {
        next_state = cur;
      };

      set(P_NEXT, x, y, next_state);

      y += 1;
    };
    x += 1;
  };

  @memory_copy(P_BOARD, P_NEXT, grid_width * grid_height * 4);
}

#start {
  @memory_grow(1);
  P_NEXT = grid_width * grid_height * 4;
  let x = 0;
  let y = 0;

  while x < grid_width {
    y = 0;
    while y < grid_height {
      set(P_NEXT, x, y, CELL_DEAD);
      if random_bool() {
        set(P_NEXT, x, y, CELL_LIVE);
      };

      y += 1;
    };
    x += 1;
  };

  @memory_copy(P_BOARD, P_NEXT, grid_width * grid_height * 4);
}
